---
url: [/rest-api]
title: .NET Core REST API
$layout: Blogtify.Client.Layout.BlogPostLayout
---


# REST: An Overview

## What is REST?

- **REST (Representational State Transfer)** is an **architectural style** for designing networked applications.
- REST is **not a standard** but relies on **principles and constraints**.
- It is **protocol agnostic**, though it is most commonly used with HTTP.

---

# Six Constraints of REST

To be considered a RESTful system, an architecture must adhere to these constraints:

1. **Client-Server**:  
   The client and server are independent entities. The server handles data storage and logic, while the client manages the user interface and user experience. This separation improves scalability and flexibility.

2. **Statelessness**:  
   Each request from a client must contain all the information necessary for the server to fulfill it. No client context is stored on the server between requests.

3. **Cacheability**:  
   Responses must explicitly state whether they are cacheable or not. This reduces unnecessary client-server interactions, improving performance.

4. **Layered System**:  
   The system can have intermediary layers (e.g., load balancers, caches) that operate independently to improve scalability and modularity.

5. **Code on Demand** _(optional)_:  
   Servers can send executable code (like JavaScript) to the client to extend its functionality.

6. **Uniform Interface**:  
   A standardized interface simplifies communication between components. It includes:
   - Identification of resources.
   - Manipulation of resources through representations.
   - Self-descriptive messages.
   - Hypermedia as the Engine of Application State (HATEOAS).

---

# Richardson Maturity Model

This model defines levels of REST API maturity:

1. **Level 0: The Swamp of POX**

   - A single URI endpoint handles all requests (e.g., SOAP).
   - Lacks distinct resources or proper use of HTTP methods.

2. **Level 1: Resources**

   - Resources are introduced, each with its own URI.
   - However, it does not properly utilize HTTP methods.

3. **Level 2: HTTP Verbs**

   - Resources are interacted with using appropriate HTTP methods (e.g., `GET`, `POST`, `PUT`, `DELETE`).

4. **Level 3: HATEOAS (Hypermedia)**
   - API responses include hypermedia links to other actions or resources, guiding the client dynamically.

---

# HTTP Methods: Safety and Idempotency

Understanding the characteristics of HTTP methods is crucial for designing RESTful APIs.

| **Method** | **Safe** | **Idempotent** | **Usage**                                      |
| ---------- | -------- | -------------- | ---------------------------------------------- |
| `GET`      | ✅ Yes   | ✅ Yes        | Retrieve data (read-only).                     |
| `POST`     | ❌ No    | ❌ No         | Create new resources or trigger actions.       |
| `PUT`      | ❌ No    | ✅ Yes        | Update or create a resource completely.        |
| `PATCH`    | ❌ No    | ❌ No         | Partially update an existing resource.         |
| `DELETE`   | ❌ No    | ✅ Yes        | Remove a resource.                             |
| `OPTIONS`  | ✅ Yes   | ✅ Yes        | Describe communication options for a resource. |

---

# Content Negotiation in REST

Content negotiation ensures that clients and servers exchange data in the desired format.

## Behavior Based on the Accept Header

1. **Header Not Present**:  
   The server responds with its default format (e.g., JSON).
2. **Unsupported Media Type**:  
   The server returns a `406 Not Acceptable` response.

### Server Configuration Example

In ASP.NET Core, you can configure content negotiation as follows:

```csharp
builder.Services.AddControllers(config =>
{
    config.RespectBrowserAcceptHeader = true;
    config.ReturnHttpNotAcceptable = true;
})
.AddXmlDataContractSerializerFormatters();
```

## Vender specific Media Types

Example: application/vnd.company.hateoas+json
Example: application/vnd.company.book.friendly.hateoas+json
Example: application/vnd.company.book.friendly+json
Example: application/vnd.company.book.full.hateoas+json
Example: application/vnd.company.book.full+json

Format: top-level-type/vendor-prefix.vendor-id.media-type-name+suffix

```csharp
public IActionResult GetBook(Guid id, [FromHeader(Name = "Accept")] string? mediaType)
{
    if (!MediaTypeHeaderValue.TryParse(mediaType, out var parsedMediaType))
    {
        return BadRequest();
    }


    var includeLinks = parsedMediaType.SubTypeWithoutSuffix
                                .EndsWith("hateoas", StringComparison.InvariantCultureIgnoreCase);

    // if includeLinks is true, include links in the response

    var primaryMediaType = includeLinks ? parsedMediaType.SubTypeWithoutSuffix
								.Substring(0, parsedMediaType.SubTypeWithoutSuffix.Length - 8)
                                : parsedMediaType.SubTypeWithoutSuffix;

    // if (primaryMediaType != "application/vnd.company.book.full")

    return Ok();
}
```

```csharp
builder.Services.Configure<MvcOptions>(config =>
{
    var newtonsoftJsonOutputFormatter = config.OutputFormatters
		.OfType<NewtonsoftJsonOutputFormatter>()
		?.FirstOrDefault();

    if (newtonsoftJsonOutputFormatter is not null)
    {
        newtonsoftJsonOutputFormatter.SupportedMediaTypes.Add("application/vnd.company.hateoas+json");
    }

    config.OutputFormatters.Add(new CsvOutputFormatter());
});
```

## Action Constraints

```csharp
[AttributeUsage(AttributeTargets.All, Inherited = true, AllowMultiple = false)]
public class RequestHeaderMatchesMediaTypeAttribute : Attribute, IActionConstraint
{
    private readonly string _requestHeaderToMatch;
    private readonly MediaTypeCollection _mediaTypes = new();

    public RequestHeaderMediaTypeAttribute(
        string requestHeaderToMatch,
        string mediaType,
        params string[] otherMediaTypes)
    {
        _requestHeaderToMatch = requestHeaderToMatch ?? throw new ArgumentNullException(nameof(requestHeaderToMatch));

        if (MediaTypeHeaderValue.TryParse(mediaType, out var parsedMediaType))
        {
		    _mediaTypes.Add(parsedMediaType);
        }
        else
        {
            throw new ArgumentException("Invalid media type.", nameof(mediaType));
        }

        foreach (var otherMediaType in otherMediaTypes)
        {
            if (MediaTypeHeaderValue.TryParse(mediaType, out var parsedOtherMediaType))
            {
                _mediaTypes.Add(parsedOtherMediaType);
            }
            else
            {
                throw new ArgumentException("Invalid media type.", nameof(otherMediaType));
            }
        }
    }

    public int Order { get; }

    public bool Accept(ActionConstraintContext context)
    {
        var requestHeaders = context.RouteContext.HttpContext.Request.Headers;
        if (!requestHeaders.ContainsKey(_requestHeaderToMatch))
        {
            return false;
        }

        var parsedRequestMediaType = new MediaType(requestHeaders[_requestHeaderToMatch]);

        foreach (var mediaType in _mediaTypes)
        {
            var parsedMediaType = new MediaType(mediaType);

            if (parsedRequestMediaType.Equals(parsedMediaType))
            {
                 return true;
            }
        }

        return false;

    }
}
```

```csharp
[RequestHeaderMediaType("Content-Type", "application/json")]
```

# Custom Validation

```csharp
builder.Services.AddControllers(config =>
{
    config.RespectBrowserAcceptHeader = true;
    config.ReturnHttpNotAcceptable = true;

    //config.OutputFormatters.Add(new CsvOutputFormatter());

})
.AddXmlDataContractSerializerFormatters()
.ConfigureApiBehaviourOptions(setupAction =>
{
    setupAction.InvalidModelStateResponseFactory = context =>
	{
        var problemDetailsFactory = context.HttpContext.RequestServices
                                            .GetRequiredService<ProblemDetailsFactory>();

        var problemDetails = problemDetailsFactory.CreateValidationProblemDetails(
			                                                    context.HttpContext,
			                                                    context.ModelState
                                                             );

        problemDetails.Detail = "See the errors field for details.";
        problemDetails.Instance = context.HttpContext.Request.Path;
        problemDetails.Type = "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/422";
        problemDetails.Status = StatusCodes.Status422UnprocessableEntity;
        problemDetails.Title = "One or more validation errors occurred.";

        problemDetails.Extensions.Add("traceId", context.HttpContext.TraceIdentifier);

		return new UnprocessableEntityObjectResult(problemDetails)
		{
            ContentTypes = { "application/problem+json" }
		};
	};
});
```

## Class Level Validation

```csharp
public class Book : IValidatableObject
{
	public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
	{
		if (PublishedAt > DateTime.UtcNow)
        {
            yeild return new ValidationResult(
                "PublishedAt must be a past date.",
                new[] { nameof(PublishedAt) }
            );
        }
	}

    [Required]
    public DateTime PublishedAt { get; set; }

}
```

## Custom Validation Attribute

```csharp
public sealed class CustomValidationAttribute : ValidationAttribute
{
	protected override ValidationResult? IsValid(object? value, ValidationContext validationContext)
	{
		if (value is null || validationContext.ObjectInstance is not BookDto book)
		{
			return new ValidationResult("The field is required.", new [] { nameof(BookDto) });
		}

		return ValidationResult.Success;
	}
}
```

## Validation at Controller Actions

# Custom Model Binders

```csharp
public class ListModelBinder : IModelBinder
{
    public Task BindModelAsync(ModelBindingContext bindingContext)
    {
        if (!bindingContext.ModelMetadata.IsEnumerableType)
        {
            bindingContext.Result = ModelBindingResult.Failed();
            return Task.CompletedTask;
        }

        var providedValue = bindingContext.ValueProvider.GetValue(bindingContext.ModelName).ToString();
        if (string.IsNullOrEmpty(providedValue))
        {
            bindingContext.Result = ModelBindingResult.Success(null);
            return Task.CompletedTask;
        }

        var genericType = bindingContext.ModelType.GetTypeInfo().GenericTypeArguments[0];
        var converter = TypeDescriptor.GetConverter(genericType);

        var objectArray = providedValue.Split(new[] { "," }, StringSplitOptions.RemoveEmptyEntries)
                                     .Select(x => converter.ConvertFromString(x.Trim()))
                                     .ToArray();
        var typedArray = Array.CreateInstance(genericType, objectArray.Length);

        objectArray.CopyTo(typedArray, 0);

        bindingContext.Model = typedArray;
        bindingContext.Result = ModelBindingResult.Success(bindingContext.Model);
        return Task.CompletedTask;
    }
}
```

```csharp
public IActionResult GetAll([ModelBinder(BinderType = typeof(ListModelBinder))] IEnumerable<Guid> ids)
{
	return Ok();
}
```

# PATCH

Must install package Microsoft.AspNetCore.Mvc.NewtonsoftJson

```csharp
builder.Services.AddControllers(config =>
{
    config.RespectBrowserAcceptHeader = true;
    config.ReturnHttpNotAcceptable = true;

    //config.OutputFormatters.Add(new CsvOutputFormatter());

})
.AddNewtonsoftJson(setupAction =>
{
    setupAction.SerizalizerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver();
})
.AddXmlDataContractSerializerFormatters(); // this should come after because the output formatter order is matter
```

```csharp

```

```csharp
public async Task<IActionResult> PartiallyUpdate(
    Guid bookId,
    JsonPatchDocument<BookRequest> patchDocument)
{
    var bookToPatch = await _bookRepository.GetBookAsync(bookId);
    if (bookToPatch == null)
	{
		return NotFound();
	}

    patchDocument.ApplyTo(bookToPatch, ModelState);

    if (!TryValidateModel(bookToPatch))
    {
        return ValidationProblem(ModelState);
    }

    // update the book in the database
    // ...

    return NocContent();
}
```

# Caching

## Cache Types

- Client Cache (Private Cache) lives on the client
- Gateway Cache/Reverse Proxy Cache (Shared Cache) lives on the server
- Proxy Cache (Shared Cache) lives on the network

## Response Cache

```csharp
[ResponseCache(Duration = 60)]
[ResponseCache(CacheProfileName = "240SecondsCacheProfile")]
```

```csharp
builder.Services.AddControllers(config =>
{
    config.CacheProfiles.Add("240SecondsCacheProfile", new CacheProfile
	{
		Duration = 240
	});
});

builder.Services.AddResponseCaching();

var app = builder.Build();

app.UseResponseCaching();
```

## Expiration Model

- Cache-Control: max-age=60
- Expires: Thu, 01 Jan 1970 00:00:00 GMT

  - -> Clocks must be synchronized
  - Offer little control
  - -> Not recommended

- Private Cache:
  - Reduces bandwidth
  - Less requests to the server
- Public Cache:
  - Doesn't reduce bandwidth between the client and the server
  - Reduces requests to the API

## Validation Model

> not supported by ResponseCache attribute and middleware

- Strong Validators:
  - Change if body or request headers of a response change
  - Can be used in any context (equality is guaranteed)
  - **Revalidate ETag by using If-None-Match header**
  - Example: ETag: "12323"
- Weak Validators:
  - Does not always change when the response changes (it's up to the server decide when to change)
  - Example: Last-Modified: Thu, 01 Jan 1970 00:00:00 GMT, ETag: "w/12323"

## Cache-Control Directives

- Response:

  - Cache type: public, private
  - Freshness: max-age, s-maxage
  - Validation:
    - no-cache: the response should not be used to satisfy a subsequent request without successful revalidation with the origin server
    - must-revalidate: if a response become expired, it must be revalidated
    - proxy-revalidate: same as must-revalidate but only for shared caches
  - Vary: Accept, Accept-Language, Accept-Encoding
  - Others:
    - no-store: the response should not be stored in any cache
    - no-transform: the media type of the response should not be transformed

- Request:
  - Freshness: max-age, min-fresh, max-stale
  - Validation: no-cache
  - Others: no-store, no-transform, only-if-cached

## Supporting ETags

**Install package Marvin.Cache.Headers**

```csharp
builder.Services.AddHttpCacheHeaders();

var app = builder.Build();

// go after the UseResponseCaching
app.UseHttpCacheHeaders(expirationModelOptions =>
{
    expirationModelOptions.MaxAge = 60;
    expirationModelOptions.CacheLocation = Marvin.Cache.Headers.CacheLocation.Private;

}, validationModelOptions =>
{
    validationModelOptions.ProxyRevalidate = true;
});
```

**Resource Level**

```csharp
[HttpCacheExpiration(CacheLocation = CacheLocation.Public, MaxAge = 60)]
[HttpCacheValidation(MustRevalidate = true)]
```

**For complicate scenarios, don't use Microsoft.AspNetCore.ResponseCaching**

### Popular Shared Cache Servers

- Varnish
- Squid
- Apache Traffic Server

## Popular CDNs

- Azure CDN
- Cloudflare
- Akamai

## Invalidate Cache

# Concurrent

# Pessimistic Concurrency

Resource is locked. while it's locked, it cannot be modified by other users.

This is not possible in REST because REST is stateless.

# Optimistic Concurrency

Token is returned together with the resource.
The update can happen as long as the token is valid. ETags are used as validation tokens.

**Install package Marvin.Cache.Headers**

- Send ETag in If-Match header
- On mismatch, return 412 Precondition Failed

# Mapping Service

```csharp
public class PropertyMappingValue
{
	public IEnumerable<string> DestinationProperties { get; private set; }
	public bool Revert { get; private set; }

	public PropertyMappingValue(IEnumerable<string> destinationProperties, bool revert = false)
	{
        DestinationProperties = destinationProperties ?? throw new ArgumentNullException(nameof(destinationProperties));
		Revert = revert;
	}
}

public class PropertMappingService : IPropertyMappingService
{
    private readonly Dictionary<string, PropertyMappingValue> _authorPropertyMapping =
		new Dictionary<string, PropertyMappingValue>(StringComparer.OrdinalIgnoreCase)
        {
		    { "Id", new PropertyMappingValue(new List<string> { "Id" }) },
		    { "Genre", new PropertyMappingValue(new List<string> { "Genre" }) },
		    { "Age", new PropertyMappingValue(new List<string> { "DateOfBirth" }, true) },
		    { "Name", new PropertyMappingValue(new List<string> { "FirstName", "LastName" }) }
        };

	private readonly IList<IPropertyMapping> _propertyMappings = new List<IPropertyMapping>();

	public PropertMappingService()
	{
	    _propertyMappings.Add(new PropertyMapping<AuthorDto, Author>(_authorPropertyMapping));
	}

	public Dictionary<string, PropertyMappingValue> GetPropertyMapping<TSource, TDestination>()
	{
		var matchingMapping = _propertyMappings.OfType<PropertyMapping<TSource, TDestination>>();
		if (matchingMapping.Count() == 1)
		{
			return matchingMapping.First().MappingDictionary;
		}

		throw new Exception($"Cannot find exact property mapping instance for <{typeof(TSource)}, {typeof(TDestination)}>");
	}
}

public interface IPropertyMapping
{
}
public class PropertMapping<TSource, TDestination> : IPropertyMapping
{
    public Dictionary<string, PropertyMappingValue> MappingDictionary { get; private set; }

    public PropertMapping(Dictionary<string, PropertyMappingValue> mappingDictionary)
    {
        MappingDictionary = mappingDictionary ?? throw new ArgumentNullException(nameof(mappingDictionary));
	}
}
```
